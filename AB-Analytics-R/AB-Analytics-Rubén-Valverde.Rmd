---
title: "Impacto de la inflación en la Macroeconomia"
author: "Rubén Valverde Romero"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    fig_width: 12 
    fig_height: 6   
    css: style.css
    theme: cosmo
    toc: true
    toc_float:
      collapsed: true
---

## Introducción {#introduccion}

En este informe se tiene como objetivo analizar que relación tiene la inflación con el crecimiento de la productividad, recaudación estatal
y la corrupción que perciben los ciudadanos.

### Origen de los Datos {#obtencion-de-los-datos}

Los datos utilizados en este análisis provienen de 2 fuentes:

-   **Inflación**: Los datos de inflación anual por país y región se obtuvieron del [Fondo Monetario
    Internacional](https://www.imf.org/external/datamapper/NGDP_RPCH@WEO/OEMDC/ADVEC/WEOWORLD "Fondo Monetario Internacional").

-   **PIB**: Los datos que tratan sobre producto interior bruto provienen del [Fondo Monetario
    Internacional](https://www.imf.org/external/datamapper/NGDPD@WEO/WEOWORLD "Fondo Monetario Internacional").

-   **Ingreso Fiscal**: Los datos de presión fiscal provienen del [Fondo Monetario
    Internacional](https://www.imf.org/external/datamapper/rev@FPP/USA/FRA/JPN/GBR/SWE/ESP/ITA/ZAF/IND/URY/VEN "Fondo Monetario Internacional").

-   **PIB per Capita**: Los datos de PIB per capita provienen del [Fondo Monetario
    Internacional](https://www.imf.org/external/datamapper/NGDPDPC@WEO/OEMDC/ADVEC/WEOWORLD "Fondo Monetario Internacional").

-   **Índice de Percepción de Corrupción (CPI)**: Los datos del CPI se obtuvieron de
    [transparency.org](https://www.transparency.org/en/ "Transparency.org"), una organización sin fines de lucro que publica anualmente el
    índice de percepción de corrupción.

## Extracción de Datos {#extraccion-de-datos}

```{r message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
library(tidyr)
library(dplyr)
library(ggplot2)
library(ggthemes)
library(RColorBrewer)
library(ggcorrplot)
library(readxl)
library(plotly)
library(scales)
library(reshape2)
library(corrplot)
library(stringdist)
```

### Importación de Datos del FMI {#importacion-de-datos}

```{r message=FALSE, warning=FALSE}

# Inflación
inflacion <- read_excel("datasets/imf-dm-export-inflacion.xlsx")[, c(-2, -3)]
head(inflacion[0:2])

# PIB
pib <- read_excel("datasets/imf-dm-export-pib.xls")
head(pib[0:2])

# Ingreso Fiscal
ingreso_fiscal <- read_excel("datasets/imf-dm-export-presion-fiscal.xls")
head(ingreso_fiscal[0:2])

# PIB per Capita
pib_per_capita <- read_excel("datasets/imf-dm-export-pib-per-capita.xls")
head(pib_per_capita[0:2])

```

### Función para formatear los df del FMI {#funcion-fmi}

```{r message=FALSE, warning=FALSE}

# Función para formatear los datos del FMI

formatear_fmi <- function(df, valor) {
  
  # Contar los datos nulos
  df <- df %>% replace(df == "no data", NA)
  print(paste("Total Nulos:", sum(is.na(df))))
  
  # Eliminar los datos nulos
  df <- df %>% drop_na()
  
  # Seleccionar las columnas de los años
  años <- colnames(df)[-1]
  
  # Cambiar el nombre de la columna de país
  colnames(df)[1] <- "pais"
  
  # Convertir las columnas a valores numéricos
  df <- df %>% mutate_at(vars(-pais), as.numeric)
    
  # Transformar el DataFrame de formato ancho a formato largo
  df <- df %>% pivot_longer(cols = all_of(años)
                            , names_to ="año", 
                            values_to = valor) %>%
               mutate(año = as.numeric(año))

  # Convertir todas la columnas menos pais a numerico
  df <- df %>% mutate(across(c(valor, año), as.numeric))
  
  # Mostrar los primeros registros y el resumen de los datos
  print("Primeros Registros:")
  print(head(df))
  
  print("Resumen de los Datos:")
  print(summary(df))
  
  return(df)
}

```

### Union de los Datos del FMI {#pib}

```{r message=FALSE, warning=FALSE}

# Formatear los datos de Inflación
inflacion <- formatear_fmi(inflacion, "inflacion")

```

```{r message=FALSE, warning=FALSE}

# Formatear los datos del PIB
pib <- formatear_fmi(pib, "pib")

```

```{r message=FALSE, warning=FALSE}
# Formatear los datos de Ingreso Fiscal
ingreso_fiscal <- formatear_fmi(ingreso_fiscal, "ingreso_fiscal")

```

```{r message=FALSE, warning=FALSE}
# Formatear los datos de PIB per Capita
pib_per_capita <- formatear_fmi(pib_per_capita, "pib_per_capita")
```

```{r message=FALSE, warning=FALSE}

# Unir los datos del FMI
fmi <- pib %>%
    full_join(ingreso_fiscal, by = c("pais", "año")) %>%
    full_join(pib_per_capita, by = c("pais", "año")) %>%
    full_join(inflacion, by = c("pais", "año"))


# Filtrar los datos a partir de 1995
fmi <- fmi %>% filter(año >= 1995)
```

### Importación de Datos del CPI {#importacion-de-datos-cpi}

#### Importar y unir datos del CPI de 1995 hasta 2011 {#funcion-cpi}

```{r message=FALSE, warning=FALSE}

cpi <- read.csv("datasets/cpi/CPI-Archive-2011.csv")[c(1,4)] 
colnames(cpi) <- c("pais","score")

for (año in 2010:1995) {

  # Importar los datos del CPI
  cpi_año <- read.csv(paste0("datasets/cpi/CPI-Archive-",año,".csv"))[c(1,4)]
  
  # Cambiar el nombre de la columna de país
  colnames(cpi_año)[1] <- "pais"
  
  # Unir los datos del CPI
  cpi <- cpi %>%
    left_join(cpi_año, by = "pais", suffix = c("", año))
}

colnames(cpi)[2] <- "score2011"


# Convertir las columnas a numérico por error al pivotar
cpi <- cpi %>% mutate(across(starts_with("score"), as.numeric))

cpi <- cpi %>% pivot_longer( cols = starts_with("score"), names_to = "año", names_prefix = "score", values_to = "cpi")

# Ajustar la escala
cpi$cpi <- cpi$cpi * 10

cpi <- cpi %>% drop_na() %>% mutate(año = as.numeric(año))

# Importar el resto de años
cpi_2012_2022 <- read_excel("datasets/cpi/CPI-Archive-2012-2023.xlsx")[c(1,3,5)] 

# Cambiar el nombre de las columnas
colnames(cpi_2012_2022) <- c("pais","año", "cpi")

# Pasar a numérico
cpi_2012_2022 <- cpi_2012_2022 %>% mutate(cpi = as.numeric(cpi),
                                          año = as.numeric(año))

# Unificar los nombres con Jaro-Winkler

  distancias <- stringdistmatrix(cpi$pais, cpi_2012_2022$pais, method = "jw")
  
  indices <- apply(distancias, 1, which.min)
  
  nombres_equivalentes <-  cpi_2012_2022$pais[indices]
  
  cpi$pais <- nombres_equivalentes
  
# Unir los datos del CPI verticalmente
cpi <- rbind(cpi, cpi_2012_2022)
```

**Explicación Jaro-Winkler:**

La fórmula del algoritmo **Jaro-Winkler** se basa en tres componentes principales: la coincidencia de caracteres, la transposición de
caracteres y un factor de penalización para las diferencias en las primeras letras de las cadenas.

1.  **Similitud de Jaro**:

$$ S_{j} = \frac{1}{3} \left( \frac{m}{|s_1|} + \frac{m}{|s_2|} + \frac{m - t}{m} \right) $$

Donde: - $s_1$ y $s_2$ son las cadenas de texto que se comparan. - $|s_1|$ y $|s_2|$ son las longitudes de las cadenas. - $m$ es el número
de caracteres coincidentes entre las dos cadenas. - $t$ es el número de transposiciones, es decir, el número de caracteres coincidentes que
están fuera de lugar.

2.  **Similitud de Jaro-Winkler**:

$$ S_{jw} =S_{j} + \ell \cdot p \cdot (1 - S_j) $$

Donde:

1.  $S_{j}$: Similitud de Jaro.
2.  $\ell$: Longitud del prefijo común al inicio de las cadenas (máximo 4 caracteres).
3.  $p$: Escalador de peso para el prefijo (normalmente $p = 0.1$).

Esta fórmula combina la similitud de Jaro y un ajuste adicional premiando las coincidencias de los primeros caracteres.

--------------------------------------------------------------------------------------------------------------------------------------------

**Ejemplo 1: "Corea" y "Korea"**

**Cálculo de** $S_j$:

1.  **Coincidencias (**$m$): Los caracteres coincidentes son: $o, r, e, a$ (4 caracteres).
2.  **Longitud de las cadenas (**$|s_1|, |s_2|$): Ambas tienen longitud 5.
3.  **Transposiciones (**$t$): Hay una transposición entre $C$ y $K$. Esto equivale a $t = 1/2 = 0.5$.

Sustituyendo en la fórmula de $S_j$:
$$ S_j = \frac{1}{3} \left( \frac{4}{5} + \frac{4}{5} + \frac{4 - 0.5}{4} \right) = \frac{1}{3} \left( 0.8 + 0.8 + 0.875 \right) = 0.825 $$

**Cálculo de** $S_{jw}$:

1.  **Prefijo común (**$\ell$): El prefijo común es vacío ($\ell = 0$).
2.  **Factor de prefijo (**$p$): $p = 0.1$.

$$ S_{jw} = S_j + \ell \cdot p \cdot (1 - S_j) = 0.825 + 0 \cdot 0.1 \cdot (1 - 0.825) = 0.825 $$

--------------------------------------------------------------------------------------------------------------------------------------------

**Ejemplo 2: "Corea" y "Correa"**

**Cálculo de** $S_j$:

1.  **Coincidencias (**$m$): Los caracteres coincidentes son: $C, o, r, e, a$ (5 caracteres).
2.  **Longitud de las cadenas (**$|s_1|, |s_2|$): Las longitudes son 5 y 6.
3.  **Transposiciones (**$t$): Hay 1 transposición por el carácter extra $r$. Esto equivale a $t = 1/2 = 0.5$.

Sustituyendo en la fórmula de $S_j$:
$$ S_j = \frac{1}{3} \left( \frac{5}{5} + \frac{5}{6} + \frac{5 - 0.5}{5} \right) = \frac{1}{3} \left( 1 + 0.833 + 0.9 \right) = 0.911 $$

**Cálculo de** $S_{jw}$:

1.  **Prefijo común (**$\ell$): El prefijo común es $C, o, r$ ($\ell = 3$).
2.  **Factor de prefijo (**$p$): $p = 0.1$.

$$ S_{jw} = S_j + \ell \cdot p \cdot (1 - S_j) = 0.911 + 3 \cdot 0.1 \cdot (1 - 0.911) $$

Resolviendo: $$ S_{jw} = 0.911 + 0.3 \cdot 0.089 = 0.911 + 0.027 = 0.938 $$

--------------------------------------------------------------------------------------------------------------------------------------------

**Resultados:**

-   "Corea" y "Korea": $S_{jw} = 0.825$.
-   "Corea" y "Correa": $S_{jw} = 0.938$.

Se puede observar que a pesar de que "Correa" tiene más caracteres al no necesitar transposiciones obtiene un mayor porcentaje de similitud.
En este caso concreto, el algoritmo Jaro-Winkler **no** seria capaz de identificar correctamente cual de las dos palabras también da nombre
al país.

### Unir los Datos del FMI con el CPI {#unir-datos-cpi}

```{r message=FALSE, warning=FALSE}

# Cambio el nombre del pais de "Korea, Republic of" a "Korea (South)"

fmi$pais <- ifelse(fmi$pais == "Korea, Republic of", "Korea (South)", fmi$pais)

# Calcula la distancia de similitud entre los nombres de los países
distancias <- stringdistmatrix(fmi$pais, cpi$pais, method = "jw")

# Encuentra los nombres más cercanos
indices <- apply(distancias, 1, which.min)
similitudes <- apply(distancias, 1, min)
nombres_equivalentes <- cpi$pais[indices]

# Calcula el porcentaje de error estimado
porcentaje_error <- similitudes * 100

# Añadir el porcentaje de error estimado al dataframe original
fmi <- fmi %>%
  mutate(porcentaje_error = porcentaje_error,
         pais = nombres_equivalentes)

# Filtrar los datos con un porcentaje de error mayor al 27.5%
fmi <- fmi %>% filter(porcentaje_error < 27.5)

# Unir los datos de inflación y CPI con los datos del FMI
df <- cpi %>%
  inner_join(fmi, by = c("pais", "año"))

# Reordenar las columnas
df <- df %>%
      select(pais, año, cpi, inflacion, pib,  pib_per_capita, ingreso_fiscal) %>%
      arrange(pais, año) 

summary(df)
head(df)
```

### Descripción de los datos del DataFrame Final {#descripcion-del-dataframe-transformado}

1.  **País**:
    -   Tipo de dato: Carácter.
    -   Descripción: Nombre del país.
2.  **Año**:
    -   Tipo de dato: Numérico.
    -   Descripción: Año al que pertenecen los datos.
3.  **Puntuación de Corrupción (CPI)**:
    -   Tipo de dato: Numérico.
    -   Descripción: Representa la percepción de corrupción en el sector público de un país en una escala de 0 a 100, donde 0 indica una
        alta percepción de corrupción y 100 indica una baja percepción de corrupción.
4.  **Inflación**:
    -   Tipo de dato: Numérico.
    -   Descripción: Representa la perdida de poder adquisitivo de los ciudadanos.
5.  **PIB:**
    -   Tipo de dato: Numérico.
    -   Descripción: Representa el valor total de todos los bienes y servicios producidos en un país en un año determinado.
6.  **PIB per Capita**:
    -   Tipo de dato: Numérico.
    -   Descripción: Representa el valor total de todos los bienes y servicios producidos en un país en un año determinado dividido por la
        población total del país.
7.  **Crecimiento del PIB per Capita**:
    -   Tipo de dato: Numérico.
    -   Descripción: Representa el crecimiento del PIB per Capita en un año determinado.
8.  **Ingresos_fiscales**:
    -   Tipo de dato: Numérico.
    -   Descripción: Representa la cantidad total de ingresos recaudados por el estado a través de impuestos, expresado en % del PIB. No
        tiene en cuenta el endeudamiento.

## Análisis Exploratorio de Datos {#eda}

### Numero de Datos por año {#falta-de-datos}

```{r}
# Contar el número de nulos por año
df_año <- df %>% group_by(año) %>% summarise(n = n()) 
df <- df %>% ungroup()

año_plot <-  ggplot(df_año, aes(x = año, y = n)) +
  geom_bar(stat = "identity", fill = "#d2c0e8", color="#978aa7") +
  labs(title = "Número de Datos por Año",
       x = "Año",
       y = "Número de Datos")
año_plot <- ggplotly(año_plot)
año_plot

```


### Visualización de los Datos en el tiempo {#visualizacion-de-los-datos}

```{r fig.height= 6}
# Seleccionar las columnas de interés
# Agrupar y calcular las medias por año
df_avg <- df %>%
  group_by(año) %>%
  summarise(
    cpi = mean(cpi, na.rm = TRUE),
    inflacion = mean(inflacion, na.rm = TRUE),
    pib = mean(pib, na.rm = TRUE),
    pib_per_capita = mean(pib_per_capita, na.rm = TRUE),
    ingreso_fiscal = mean(ingreso_fiscal, na.rm = TRUE), 
    .groups = "drop"
  )

# Transformar a formato largo
df_avg_valores_llaves <- df_avg %>%
  pivot_longer(cols = -año, names_to = "variable", values_to = "valor")

# Crear el gráfico
plot <- ggplot(df_avg_valores_llaves, aes(x = año, y = valor, color = variable)) +
  geom_line() +
  geom_point(size = 2) +
  facet_wrap(~variable, scales = "free") +
  labs(
    title = "Evolución de las Variables Numéricas (1995-2022) ",
    x = "Año",
    y = ""
  ) +
  theme(legend.position = "none",
        panel.spacing.x = unit(2, "lines"),
        panel.spacing.y = unit(4, "lines"))

# Convertir a objeto plotly
ggplotly(plot)

```

### Visualización de las distribuciones {#visualizacion-distribuciones}

```{r, warning=FALSE, message=FALSE, fig.height= 6}

# Seleccionar las columnas de interés
df_correlacion <- df %>% select(-pais, -año) %>%
                  mutate( inflacion = log2(inflacion),
                          pib = log2(pib),
                          pib_per_capita = log2(pib_per_capita),
                          ingreso_fiscal = log2(ingreso_fiscal)
                  ) 

# Transformar el DataFrame de formato ancho a formato largo
df_correlacion_valores_llaves <- df_correlacion %>% gather(variable, valor)

# Crear un gráfico de densidad para cada variable
plot <- ggplot(df_correlacion_valores_llaves, aes(x = valor, fill = variable)) +
  geom_density() +
  facet_wrap(~variable, scales = "free") +
  labs(title = "Distribución de las Variables Numéricas",
       x = "",
       y = "") +
  theme(legend.position = "none",
        panel.spacing.x = unit(1, "lines"),
        panel.spacing.y = unit(3, "lines"))

# Convertir a objeto plotly
ggplotly(plot)

```

### Calculo de la matriz de correlación

```{r Matriz de Correlación, warning=FALSE}

df_correlacion <- df %>% select(-pais, -año)

# Crear matrices vacías para almacenar p-valores más bajos, métodos y coeficientes de correlación
n <- ncol(df_correlacion)
metodos <- c("pearson", "spearman")
p_metodo <- matrix(" ", n, n, dimnames = list(names(df_correlacion), names(df_correlacion)))
cor_matrix <- matrix(1, n, n, dimnames = list(names(df_correlacion), names(df_correlacion)))

# Iterar sobre las combinaciones de pares de columnas
for (j in 1:(n-1)) {
  for (k in (j+1):n) {
    var1 <- names(df_correlacion)[j]
    var2 <- names(df_correlacion)[k]
    p_valores <- sapply(metodos, function(metodo) cor.test(df_correlacion[[var1]], df_correlacion[[var2]], method = metodo, use ="complete.obs")$p.value)
    
    # Identificar el p-valor más bajo y el método correspondiente
    metodo_elegido <- metodos[which.min(p_valores)]
    p_valor_minimo <- min(p_valores)
    
    # Calcular el coeficiente de correlación usando el método elegido
    correlacion <- cor(df[[var1]], df[[var2]], method = metodo_elegido, use ="complete.obs")
    
    # Almacenar el p-valor más bajo, el método elegido y el coeficiente de correlación
    p_metodo[var1, var2] <- metodo_elegido
    p_metodo[var2, var1] <- format(p_valor_minimo, digits = 2, scientific = TRUE)
    
    cor_matrix[var1, var2] <- correlacion
    cor_matrix[var2, var1] <- correlacion
  }
}
cor_matrix
```

### Visualización de la matriz de p-valores y métodos

```{r}
# Convertir la matriz de métodos en un dataframe adecuado para ggplot
p_metodo_df <- melt(p_metodo, varnames = c("Variable1", "Variable2"), value.name = "Valor")

# Crear la visualización
method_plot <- ggplot(data = p_metodo_df, aes(x = Variable1, y = Variable2, fill = Valor)) + 
  geom_tile(color = "black") +  
  geom_text(aes(label = Valor), 
            size = 4, 
            color = "black") + 
  scale_fill_manual(values = c("pearson" = "#e033ff", "spearman" = "#fdaf7a"," " = "#696969"),na.value = "#e0ffbf") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        axis.line = element_line(color = "black"),
        panel.background = element_rect(fill = "#f9f9f9", color = NA),  
        plot.background = element_rect(fill = "#f9f9f9", color = NA),   
        legend.position = "none") +
  labs(title = "Métodos de Correlación Utilizados y sus P-Valores", 
       x = "", 
       y = "", 
       fill = "Método")


method_plot <- ggplotly(method_plot) %>% 
               layout(autosize = TRUE, 
                     xaxis = list(autorange = TRUE))

method_plot
```

### Visualización de la matriz de correlación

```{r fig.height= 7, fig.width = 7}

corrplot <-ggcorrplot(cor_matrix, 
           method = "circle",
           type = "full",
           lab = TRUE,
           lab_size = 3, 
           colors = c("#6400e4","white", "#e40000"), 
           title = "       Matriz de Correlación") +
  
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
    panel.background = element_rect(fill = "#f9f9f9", color = NA),  
    plot.background = element_rect(fill = "#f9f9f9", color = NA),   
    axis.title = element_text(size = 3),
    axis.text = element_text(size = 1))

ggsave("corrplot.png", plot = corrplot, width = 5, height = 3.75, dpi = 400)
knitr::include_graphics("corrplot.png")
```
