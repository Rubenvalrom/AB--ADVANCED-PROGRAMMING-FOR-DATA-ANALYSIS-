# Iterar sobre las combinaciones de pares de columnas
for (j in 1:(n-1)) {
for (k in (j+1):n) {
var1 <- names(df_correlacion)[j]
var2 <- names(df_correlacion)[k]
p_valores <- sapply(metodos, function(metodo) cor.test(df_correlacion[[var1]], df_correlacion[[var2]], method = metodo, na.rm=TRUE)$p.value)
# Identificar el p-valor más bajo y el método correspondiente
metodo_elegido <- metodos[which.min(p_valores)]
p_valor_minimo <- min(p_valores)
# Calcular el coeficiente de correlación usando el método elegido
correlacion <- cor(df[[var1]], df[[var2]], method = metodo_elegido, na.rm=TRUE)
# Almacenar el p-valor más bajo, el método elegido y el coeficiente de correlación
p_metodo[var1, var2] <- metodo_elegido
p_metodo[var2, var1] <- format(p_valor_minimo, digits = 2, scientific = TRUE)
cor_matrix[var1, var2] <- correlacion
cor_matrix[var2, var1] <- correlacion
}
}
df <- df %>% ungroup()
df_correlacion <- df %>% select(-pais, -año)
# Crear matrices vacías para almacenar p-valores más bajos, métodos y coeficientes de correlación
n <- ncol(df_correlacion)
metodos <- c("pearson", "spearman")
p_metodo <- matrix(" ", n, n, dimnames = list(names(df_correlacion), names(df_correlacion)))
cor_matrix <- matrix(1, n, n, dimnames = list(names(df_correlacion), names(df_correlacion)))
# Iterar sobre las combinaciones de pares de columnas
for (j in 1:(n-1)) {
for (k in (j+1):n) {
var1 <- names(df_correlacion)[j]
var2 <- names(df_correlacion)[k]
p_valores <- sapply(metodos, function(metodo) cor.test(df_correlacion[[var1]], df_correlacion[[var2]], method = metodo)$p.value)
# Identificar el p-valor más bajo y el método correspondiente
metodo_elegido <- metodos[which.min(p_valores)]
p_valor_minimo <- min(p_valores)
# Calcular el coeficiente de correlación usando el método elegido
correlacion <- cor(df[[var1]], df[[var2]], method = metodo_elegido, na.rm=TRUE)
# Almacenar el p-valor más bajo, el método elegido y el coeficiente de correlación
p_metodo[var1, var2] <- metodo_elegido
p_metodo[var2, var1] <- format(p_valor_minimo, digits = 2, scientific = TRUE)
cor_matrix[var1, var2] <- correlacion
cor_matrix[var2, var1] <- correlacion
}
}
df <- df %>% drop_na()
df_correlacion <- df %>% select(-pais, -año)
# Crear matrices vacías para almacenar p-valores más bajos, métodos y coeficientes de correlación
n <- ncol(df_correlacion)
metodos <- c("pearson", "spearman")
p_metodo <- matrix(" ", n, n, dimnames = list(names(df_correlacion), names(df_correlacion)))
cor_matrix <- matrix(1, n, n, dimnames = list(names(df_correlacion), names(df_correlacion)))
# Iterar sobre las combinaciones de pares de columnas
for (j in 1:(n-1)) {
for (k in (j+1):n) {
var1 <- names(df_correlacion)[j]
var2 <- names(df_correlacion)[k]
p_valores <- sapply(metodos, function(metodo) cor.test(df_correlacion[[var1]], df_correlacion[[var2]], method = metodo)$p.value)
# Identificar el p-valor más bajo y el método correspondiente
metodo_elegido <- metodos[which.min(p_valores)]
p_valor_minimo <- min(p_valores)
# Calcular el coeficiente de correlación usando el método elegido
correlacion <- cor(df[[var1]], df[[var2]], method = metodo_elegido)
# Almacenar el p-valor más bajo, el método elegido y el coeficiente de correlación
p_metodo[var1, var2] <- metodo_elegido
p_metodo[var2, var1] <- format(p_valor_minimo, digits = 2, scientific = TRUE)
cor_matrix[var1, var2] <- correlacion
cor_matrix[var2, var1] <- correlacion
}
}
cor_matrix
df <- df %>% drop_na()
df_correlacion <- df %>% select(-pais, -año)
# Crear matrices vacías para almacenar p-valores más bajos, métodos y coeficientes de correlación
n <- ncol(df_correlacion)
metodos <- c("pearson", "spearman")
p_metodo <- matrix(" ", n, n, dimnames = list(names(df_correlacion), names(df_correlacion)))
cor_matrix <- matrix(1, n, n, dimnames = list(names(df_correlacion), names(df_correlacion)))
# Iterar sobre las combinaciones de pares de columnas
for (j in 1:(n-1)) {
for (k in (j+1):n) {
var1 <- names(df_correlacion)[j]
var2 <- names(df_correlacion)[k]
p_valores <- sapply(metodos, function(metodo) cor.test(df_correlacion[[var1]], df_correlacion[[var2]], method = metodo)$p.value)
# Identificar el p-valor más bajo y el método correspondiente
metodo_elegido <- metodos[which.min(p_valores)]
p_valor_minimo <- min(p_valores)
# Calcular el coeficiente de correlación usando el método elegido
correlacion <- cor(df[[var1]], df[[var2]], method = metodo_elegido, use ="complete.obs" )
# Almacenar el p-valor más bajo, el método elegido y el coeficiente de correlación
p_metodo[var1, var2] <- metodo_elegido
p_metodo[var2, var1] <- format(p_valor_minimo, digits = 2, scientific = TRUE)
cor_matrix[var1, var2] <- correlacion
cor_matrix[var2, var1] <- correlacion
}
}
cor_matrix
df_correlacion <- df %>% select(-pais, -año)
# Crear matrices vacías para almacenar p-valores más bajos, métodos y coeficientes de correlación
n <- ncol(df_correlacion)
metodos <- c("pearson", "spearman")
p_metodo <- matrix(" ", n, n, dimnames = list(names(df_correlacion), names(df_correlacion)))
cor_matrix <- matrix(1, n, n, dimnames = list(names(df_correlacion), names(df_correlacion)))
# Iterar sobre las combinaciones de pares de columnas
for (j in 1:(n-1)) {
for (k in (j+1):n) {
var1 <- names(df_correlacion)[j]
var2 <- names(df_correlacion)[k]
p_valores <- sapply(metodos, function(metodo) cor.test(df_correlacion[[var1]], df_correlacion[[var2]], method = metodo)$p.value)
# Identificar el p-valor más bajo y el método correspondiente
metodo_elegido <- metodos[which.min(p_valores)]
p_valor_minimo <- min(p_valores)
# Calcular el coeficiente de correlación usando el método elegido
correlacion <- cor(df[[var1]], df[[var2]], method = metodo_elegido, use ="complete.obs" )
# Almacenar el p-valor más bajo, el método elegido y el coeficiente de correlación
p_metodo[var1, var2] <- metodo_elegido
p_metodo[var2, var1] <- format(p_valor_minimo, digits = 2, scientific = TRUE)
cor_matrix[var1, var2] <- correlacion
cor_matrix[var2, var1] <- correlacion
}
}
cor_matrix
df_correlacion <- df %>% select(-pais, -año)
# Crear matrices vacías para almacenar p-valores más bajos, métodos y coeficientes de correlación
n <- ncol(df_correlacion)
metodos <- c("pearson", "spearman")
p_metodo <- matrix(" ", n, n, dimnames = list(names(df_correlacion), names(df_correlacion)))
cor_matrix <- matrix(1, n, n, dimnames = list(names(df_correlacion), names(df_correlacion)))
# Iterar sobre las combinaciones de pares de columnas
for (j in 1:(n-1)) {
for (k in (j+1):n) {
var1 <- names(df_correlacion)[j]
var2 <- names(df_correlacion)[k]
p_valores <- sapply(metodos, function(metodo) cor.test(df_correlacion[[var1]], df_correlacion[[var2]], method = metodo)$p.value)
# Identificar el p-valor más bajo y el método correspondiente
metodo_elegido <- metodos[which.min(p_valores)]
p_valor_minimo <- min(p_valores)
# Calcular el coeficiente de correlación usando el método elegido
correlacion <- cor(df[[var1]], df[[var2]], method = metodo_elegido, use ="complete.obs" )
# Almacenar el p-valor más bajo, el método elegido y el coeficiente de correlación
p_metodo[var1, var2] <- metodo_elegido
p_metodo[var2, var1] <- format(p_valor_minimo, digits = 2, scientific = TRUE)
cor_matrix[var1, var2] <- correlacion
cor_matrix[var2, var1] <- correlacion
}
}
cor_matrix
df_correlacion <- df %>% select(-pais, -año)
# Crear matrices vacías para almacenar p-valores más bajos, métodos y coeficientes de correlación
n <- ncol(df_correlacion)
metodos <- c("pearson", "spearman")
p_metodo <- matrix(" ", n, n, dimnames = list(names(df_correlacion), names(df_correlacion)))
cor_matrix <- matrix(1, n, n, dimnames = list(names(df_correlacion), names(df_correlacion)))
# Iterar sobre las combinaciones de pares de columnas
for (j in 1:(n-1)) {
for (k in (j+1):n) {
var1 <- names(df_correlacion)[j]
var2 <- names(df_correlacion)[k]
p_valores <- sapply(metodos, function(metodo) cor.test(df_correlacion[[var1]], df_correlacion[[var2]], method = metodo, use ="complete.obs")$p.value)
# Identificar el p-valor más bajo y el método correspondiente
metodo_elegido <- metodos[which.min(p_valores)]
p_valor_minimo <- min(p_valores)
# Calcular el coeficiente de correlación usando el método elegido
correlacion <- cor(df[[var1]], df[[var2]], method = metodo_elegido, use ="complete.obs")
# Almacenar el p-valor más bajo, el método elegido y el coeficiente de correlación
p_metodo[var1, var2] <- metodo_elegido
p_metodo[var2, var1] <- format(p_valor_minimo, digits = 2, scientific = TRUE)
cor_matrix[var1, var2] <- correlacion
cor_matrix[var2, var1] <- correlacion
}
}
cor_matrix
# Convertir la matriz de métodos en un dataframe adecuado para ggplot
p_metodo_df <- melt(p_metodo, varnames = c("Variable1", "Variable2"), value.name = "Valor")
# Crear la visualización
method_plot <- ggplot(data = p_metodo_df, aes(x = Variable1, y = Variable2, fill = Valor)) +
geom_tile(color = "black") +
geom_text(aes(label = Valor),
size = 4,
color = "black") +
scale_fill_manual(values = c("pearson" = "#e033ff", "spearman" = "#fdaf7a"," " = "#696969"),na.value = "#e0ffbf") +
theme(axis.text.x = element_text(angle = 45, hjust = 1),
axis.line = element_line(color = "black"),
panel.background = element_rect(fill = "#f9f9f9", color = NA),
plot.background = element_rect(fill = "#f9f9f9", color = NA),
legend.position = "none") +
labs(title = "Métodos de Correlación Utilizados y sus P-Valores",
x = "",
y = "",
fill = "Método")
method_plot <- ggplotly(method_plot) %>%
layout(autosize = TRUE,
xaxis = list(autorange = TRUE))
method_plot
corrplot <-ggcorrplot(cor_matrix,
method = "circle",
type = "full",
lab = TRUE,
lab_size = 3,
colors = c("#6400e4","white", "#e40000"),
title = "       Matriz de Correlación") +
theme(axis.text.x = element_text(angle = 45, hjust = 1),
panel.background = element_rect(fill = "#f9f9f9", color = NA),
plot.background = element_rect(fill = "#f9f9f9", color = NA),
axis.title = element_text(size = 3),
axis.text = element_text(size = 1))
ggsave("corrplot.png", plot = corrplot, width = 5.5, height = 4, dpi = 400)
knitr::include_graphics("corrplot.png")
df_correlacion <- df %>% filter(año >2006) %>% select(-pais, -año)
# Crear matrices vacías para almacenar p-valores más bajos, métodos y coeficientes de correlación
n <- ncol(df_correlacion)
metodos <- c("pearson", "spearman")
p_metodo <- matrix(" ", n, n, dimnames = list(names(df_correlacion), names(df_correlacion)))
cor_matrix <- matrix(1, n, n, dimnames = list(names(df_correlacion), names(df_correlacion)))
# Iterar sobre las combinaciones de pares de columnas
for (j in 1:(n-1)) {
for (k in (j+1):n) {
var1 <- names(df_correlacion)[j]
var2 <- names(df_correlacion)[k]
p_valores <- sapply(metodos, function(metodo) cor.test(df_correlacion[[var1]], df_correlacion[[var2]], method = metodo, use ="complete.obs")$p.value)
# Identificar el p-valor más bajo y el método correspondiente
metodo_elegido <- metodos[which.min(p_valores)]
p_valor_minimo <- min(p_valores)
# Calcular el coeficiente de correlación usando el método elegido
correlacion <- cor(df[[var1]], df[[var2]], method = metodo_elegido, use ="complete.obs")
# Almacenar el p-valor más bajo, el método elegido y el coeficiente de correlación
p_metodo[var1, var2] <- metodo_elegido
p_metodo[var2, var1] <- format(p_valor_minimo, digits = 2, scientific = TRUE)
cor_matrix[var1, var2] <- correlacion
cor_matrix[var2, var1] <- correlacion
}
}
cor_matrix
# Convertir la matriz de métodos en un dataframe adecuado para ggplot
p_metodo_df <- melt(p_metodo, varnames = c("Variable1", "Variable2"), value.name = "Valor")
# Crear la visualización
method_plot <- ggplot(data = p_metodo_df, aes(x = Variable1, y = Variable2, fill = Valor)) +
geom_tile(color = "black") +
geom_text(aes(label = Valor),
size = 4,
color = "black") +
scale_fill_manual(values = c("pearson" = "#e033ff", "spearman" = "#fdaf7a"," " = "#696969"),na.value = "#e0ffbf") +
theme(axis.text.x = element_text(angle = 45, hjust = 1),
axis.line = element_line(color = "black"),
panel.background = element_rect(fill = "#f9f9f9", color = NA),
plot.background = element_rect(fill = "#f9f9f9", color = NA),
legend.position = "none") +
labs(title = "Métodos de Correlación Utilizados y sus P-Valores",
x = "",
y = "",
fill = "Método")
method_plot <- ggplotly(method_plot) %>%
layout(autosize = TRUE,
xaxis = list(autorange = TRUE))
method_plot
corrplot <-ggcorrplot(cor_matrix,
method = "circle",
type = "full",
lab = TRUE,
lab_size = 3,
colors = c("#6400e4","white", "#e40000"),
title = "       Matriz de Correlación") +
theme(axis.text.x = element_text(angle = 45, hjust = 1),
panel.background = element_rect(fill = "#f9f9f9", color = NA),
plot.background = element_rect(fill = "#f9f9f9", color = NA),
axis.title = element_text(size = 3),
axis.text = element_text(size = 1))
ggsave("corrplot.png", plot = corrplot, width = 5.5, height = 4, dpi = 400)
knitr::include_graphics("corrplot.png")
library(tidyr)
library(dplyr)
library(ggplot2)
library(ggthemes)
library(RColorBrewer)
library(ggcorrplot)
library(readxl)
library(plotly)
library(scales)
library(reshape2)
library(corrplot)
library(stringdist)
# Inflación
inflacion <- read_excel("datasets/imf-dm-export-inflacion.xlsx")[, c(-2, -3)]
head(inflacion[0:2])
# PIB
pib <- read_excel("datasets/imf-dm-export-pib.xls")
head(pib[0:2])
# Ingreso Fiscal
ingreso_fiscal <- read_excel("datasets/imf-dm-export-presion-fiscal.xls")
head(ingreso_fiscal[0:2])
# PIB per Capita
pib_per_capita <- read_excel("datasets/imf-dm-export-pib-per-capita.xls")
head(pib_per_capita[0:2])
# Función para formatear los datos del FMI
formatear_fmi <- function(df, valor) {
# Contar los datos nulos
df <- df %>% replace(df == "no data", NA)
print(paste("Total Nulos:", sum(is.na(df))))
# Eliminar los datos nulos
df <- df %>% drop_na()
# Seleccionar las columnas de los años
años <- colnames(df)[-1]
# Cambiar el nombre de la columna de país
colnames(df)[1] <- "pais"
# Convertir las columnas a valores numéricos
df <- df %>% mutate_at(vars(-pais), as.numeric)
# Transformar el DataFrame de formato ancho a formato largo
df <- df %>% pivot_longer(cols = all_of(años)
, names_to ="año",
values_to = valor) %>%
mutate(año = as.numeric(año))
# Convertir todas la columnas menos pais a numerico
df <- df %>% mutate(across(c(valor, año), as.numeric))
# Mostrar los primeros registros y el resumen de los datos
print("Primeros Registros:")
print(head(df))
print("Resumen de los Datos:")
print(summary(df))
return(df)
}
# Formatear los datos de Inflación
inflacion <- formatear_fmi(inflacion, "inflacion")
# Formatear los datos del PIB
pib <- formatear_fmi(pib, "pib")
# Formatear los datos de Ingreso Fiscal
ingreso_fiscal <- formatear_fmi(ingreso_fiscal, "ingreso_fiscal")
# Formatear los datos de PIB per Capita
pib_per_capita <- formatear_fmi(pib_per_capita, "pib_per_capita")
# Unir los datos del FMI
fmi <- pib %>%
full_join(ingreso_fiscal, by = c("pais", "año")) %>%
full_join(pib_per_capita, by = c("pais", "año")) %>%
full_join(inflacion, by = c("pais", "año"))
# Filtrar los datos a partir de 1995
fmi <- fmi %>% filter(año >= 1995)
cpi <- read.csv("datasets/cpi/CPI-Archive-2011.csv")[c(1,4)]
colnames(cpi) <- c("pais","score")
for (año in 2010:1995) {
# Importar los datos del CPI
cpi_año <- read.csv(paste0("datasets/cpi/CPI-Archive-",año,".csv"))[c(1,4)]
# Cambiar el nombre de la columna de país
colnames(cpi_año)[1] <- "pais"
# Unir los datos del CPI
cpi <- cpi %>%
left_join(cpi_año, by = "pais", suffix = c("", año))
}
colnames(cpi)[2] <- "score2011"
# Convertir las columnas a numérico por error al pivotar
cpi <- cpi %>% mutate(across(starts_with("score"), as.numeric))
cpi <- cpi %>% pivot_longer( cols = starts_with("score"), names_to = "año", names_prefix = "score", values_to = "cpi")
# Ajustar la escala
cpi$cpi <- cpi$cpi * 10
cpi <- cpi %>% drop_na() %>% mutate(año = as.numeric(año))
# Importar el resto de años
cpi_2012_2022 <- read_excel("datasets/cpi/CPI-Archive-2012-2023.xlsx")[c(1,3,5)]
# Cambiar el nombre de las columnas
colnames(cpi_2012_2022) <- c("pais","año", "cpi")
# Pasar a numérico
cpi_2012_2022 <- cpi_2012_2022 %>% mutate(cpi = as.numeric(cpi),
año = as.numeric(año))
# Unificar los nombres con Jaro-Winkler
distancias <- stringdistmatrix(cpi$pais, cpi_2012_2022$pais, method = "jw")
indices <- apply(distancias, 1, which.min)
nombres_equivalentes <-  cpi_2012_2022$pais[indices]
cpi$pais <- nombres_equivalentes
# Unir los datos del CPI verticalmente
cpi <- rbind(cpi, cpi_2012_2022)
# Cambio el nombre del pais de "Korea, Republic of" a "Korea (South)"
fmi$pais <- ifelse(fmi$pais == "Korea, Republic of", "Korea (South)", fmi$pais)
# Calcula la distancia de similitud entre los nombres de los países
distancias <- stringdistmatrix(fmi$pais, cpi$pais, method = "jw")
# Encuentra los nombres más cercanos
indices <- apply(distancias, 1, which.min)
similitudes <- apply(distancias, 1, min)
nombres_equivalentes <- cpi$pais[indices]
# Calcula el porcentaje de error estimado
porcentaje_error <- similitudes * 100
# Añadir el porcentaje de error estimado al dataframe original
fmi <- fmi %>%
mutate(porcentaje_error = porcentaje_error,
pais = nombres_equivalentes)
# Filtrar los datos con un porcentaje de error mayor al 27.5%
fmi <- fmi %>% filter(porcentaje_error < 27.5)
# Unir los datos de inflación y CPI con los datos del FMI
df <- cpi %>%
inner_join(fmi, by = c("pais", "año"))
# Reordenar las columnas
df <- df %>%
select(pais, año, cpi, inflacion, pib,  pib_per_capita, ingreso_fiscal) %>%
arrange(pais, año)
summary(df)
head(df)
# Contar el número de nulos por año
df_año <- df %>% group_by(año) %>% summarise(n = n())
df <- df %>% ungroup()
año_plot <-  ggplot(df_año, aes(x = año, y = n)) +
geom_bar(stat = "identity", fill = "#d2c0e8", color="#978aa7") +
labs(title = "Número de Datos por Año",
x = "Año",
y = "Número de Datos")
año_plot <- ggplotly(año_plot)
año_plot
# Seleccionar las columnas de interés
# Agrupar y calcular las medias por año
df_avg <- df %>%
group_by(año) %>%
summarise(
cpi = mean(cpi, na.rm = TRUE),
inflacion = mean(inflacion, na.rm = TRUE),
pib = mean(pib, na.rm = TRUE),
pib_per_capita = mean(pib_per_capita, na.rm = TRUE),
ingreso_fiscal = mean(ingreso_fiscal, na.rm = TRUE),
.groups = "drop"
)
# Transformar a formato largo
df_avg_valores_llaves <- df_avg %>%
pivot_longer(cols = -año, names_to = "variable", values_to = "valor")
# Crear el gráfico
plot <- ggplot(df_avg_valores_llaves, aes(x = año, y = valor, color = variable)) +
geom_line() +
geom_point(size = 2) +
facet_wrap(~variable, scales = "free") +
labs(
title = "Evolución de las Variables Numéricas (1995-2022) ",
x = "Año",
y = ""
) +
theme(legend.position = "none",
panel.spacing.x = unit(2, "lines"),
panel.spacing.y = unit(4, "lines"))
# Convertir a objeto plotly
ggplotly(plot)
# Seleccionar las columnas de interés
df_correlacion <- df %>% select(-pais, -año) %>%
mutate( inflacion = log2(inflacion),
pib = log2(pib),
pib_per_capita = log2(pib_per_capita),
ingreso_fiscal = log2(ingreso_fiscal)
)
# Transformar el DataFrame de formato ancho a formato largo
df_correlacion_valores_llaves <- df_correlacion %>% gather(variable, valor)
# Crear un gráfico de densidad para cada variable
plot <- ggplot(df_correlacion_valores_llaves, aes(x = valor, fill = variable)) +
geom_density() +
facet_wrap(~variable, scales = "free") +
labs(title = "Distribución de las Variables Numéricas",
x = "",
y = "") +
theme(legend.position = "none",
panel.spacing.x = unit(1, "lines"),
panel.spacing.y = unit(3, "lines"))
# Convertir a objeto plotly
ggplotly(plot)
df_correlacion <- df %>% select(-pais, -año)
# Crear matrices vacías para almacenar p-valores más bajos, métodos y coeficientes de correlación
n <- ncol(df_correlacion)
metodos <- c("pearson", "spearman")
p_metodo <- matrix(" ", n, n, dimnames = list(names(df_correlacion), names(df_correlacion)))
cor_matrix <- matrix(1, n, n, dimnames = list(names(df_correlacion), names(df_correlacion)))
# Iterar sobre las combinaciones de pares de columnas
for (j in 1:(n-1)) {
for (k in (j+1):n) {
var1 <- names(df_correlacion)[j]
var2 <- names(df_correlacion)[k]
p_valores <- sapply(metodos, function(metodo) cor.test(df_correlacion[[var1]], df_correlacion[[var2]], method = metodo, use ="complete.obs")$p.value)
# Identificar el p-valor más bajo y el método correspondiente
metodo_elegido <- metodos[which.min(p_valores)]
p_valor_minimo <- min(p_valores)
# Calcular el coeficiente de correlación usando el método elegido
correlacion <- cor(df[[var1]], df[[var2]], method = metodo_elegido, use ="complete.obs")
# Almacenar el p-valor más bajo, el método elegido y el coeficiente de correlación
p_metodo[var1, var2] <- metodo_elegido
p_metodo[var2, var1] <- format(p_valor_minimo, digits = 2, scientific = TRUE)
cor_matrix[var1, var2] <- correlacion
cor_matrix[var2, var1] <- correlacion
}
}
cor_matrix
# Convertir la matriz de métodos en un dataframe adecuado para ggplot
p_metodo_df <- melt(p_metodo, varnames = c("Variable1", "Variable2"), value.name = "Valor")
# Crear la visualización
method_plot <- ggplot(data = p_metodo_df, aes(x = Variable1, y = Variable2, fill = Valor)) +
geom_tile(color = "black") +
geom_text(aes(label = Valor),
size = 4,
color = "black") +
scale_fill_manual(values = c("pearson" = "#e033ff", "spearman" = "#fdaf7a"," " = "#696969"),na.value = "#e0ffbf") +
theme(axis.text.x = element_text(angle = 45, hjust = 1),
axis.line = element_line(color = "black"),
panel.background = element_rect(fill = "#f9f9f9", color = NA),
plot.background = element_rect(fill = "#f9f9f9", color = NA),
legend.position = "none") +
labs(title = "Métodos de Correlación Utilizados y sus P-Valores",
x = "",
y = "",
fill = "Método")
method_plot <- ggplotly(method_plot) %>%
layout(autosize = TRUE,
xaxis = list(autorange = TRUE))
method_plot
corrplot <-ggcorrplot(cor_matrix,
method = "circle",
type = "full",
lab = TRUE,
lab_size = 3,
colors = c("#6400e4","white", "#e40000"),
title = "       Matriz de Correlación") +
theme(axis.text.x = element_text(angle = 45, hjust = 1),
panel.background = element_rect(fill = "#f9f9f9", color = NA),
plot.background = element_rect(fill = "#f9f9f9", color = NA),
axis.title = element_text(size = 3),
axis.text = element_text(size = 1))
ggsave("corrplot.png", plot = corrplot, width = 5.5, height = 4, dpi = 400)
knitr::include_graphics("corrplot.png")
